---
#############
# PREP WORK #
#############
- name: check if guix already installed
  stat:
    path: /gnu/store
  register: gnu_store_stat  # use gnu_store_stat.stat.exists

# guix signing key
- name: check if guix signing key is already imported
  command: "gpg -k {{ SIGNING_KEY_FPRINT }}"
  register: signing_key_imported
  changed_when: false  # this command is readonly
  ignore_errors: true
  always_run: yes
- name: import guix signing key if needed
  command: "gpg --keyserver keys.gnupg.net --recv-keys {{ SIGNING_KEY_FPRINT }}"
  when: signing_key_imported.rc != 0
- name: verify that guix signing key successfully imported
  command: "gpg -k {{ SIGNING_KEY_FPRINT }}"
  changed_when: false  # this command is readonly

# guix build users
- name: create guixbuild group
  group:
    name: guixbuild
    system: yes
- name: create guixbuild usergroups
  group:
    name: "guixbuilder{{ item }}"
    system: yes
    state: present
  with_sequence: start=1 end=10 format="%02d"
- name: create guixbuild users
  user:
    name: "guixbuilder{{ item }}"
    group: "guixbuilder{{ item }}"
    groups: guixbuild
    home: /var/empty
    shell: /usr/sbin/nologin
    comment: "Guix build user {{ item }}"
    system: yes
    state: present
  with_sequence: start=1 end=10 format="%02d"

# make sure we have the guix tarball even if guix is already installed
- name: fetch guix
  get_url:
    url: "{{ URL_PREFIX }}/{{ FILENAME }}"
    sha256sum: "{{ SHA256 }}"
    dest: "/usr/local/src/{{ FILENAME }}"
- name: fetch guix sig
  get_url:
    url: "{{ URL_PREFIX }}/{{ FILENAME }}.sig"
    dest: /usr/local/src
- name: verify guix
  command: "gpg --verify {{ FILENAME }}.sig"
  changed_when: false  # this command is readonly
  args:
    chdir: /usr/local/src
  always_run: yes

################
# INSTALL GUIX #
################
# This section is idempotent as long as we use gnu_store_stat.stat.exists
# appropriately to skip potentially dangerous steps.

### ---- begin dangerous stuff ---- ###
- name: ensure /tmp is clean for unarchiving
  file:
    path: /tmp/{{ item }}
    state: absent
  with_items:
  - gnu
  - var
  when: gnu_store_stat.stat.exists == false
- name: untar guix
  unarchive:
    src: "/usr/local/src/{{ FILENAME }}"
    dest: /tmp
    creates: /tmp/gnu
    copy: no
  when: gnu_store_stat.stat.exists == false
- name: create /var/guix
  command: mv var/guix /var/
  args:
    chdir: /tmp
    creates: /var/guix
  when: gnu_store_stat.stat.exists == false
- name: create /gnu
  command: mv gnu /
  args:
    chdir: /tmp
    creates: /gnu
  when: gnu_store_stat.stat.exists == false
### ---- end dangerous stuff ---- ###

- name: create guix profile for root
  file:
    src: /var/guix/profiles/per-user/root/guix-profile
    dest: /root/.guix-profile
    state: link
- name: make the guix utility available everywhere
  file:
    src: /var/guix/profiles/per-user/root/guix-profile/bin/guix
    dest: /usr/local/bin/guix
    state: link

# setup or update guix-daemon systemd service
- name: get hash of current guix-daemon systemd service file
  stat:
    path: /etc/systemd/system/guix-daemon.service
    get_md5: true
  register: current_service_file
- name: get hash of new guix-daemon systemd service file
  stat:
    path: /root/.guix-profile/lib/systemd/system/guix-daemon.service
    get_md5: true
  register: new_service_file
  when: current_service_file.stat.exists
- name: setup/update guix-daemon systemd service file
  command: cp /root/.guix-profile/lib/systemd/system/guix-daemon.service /etc/systemd/system/
  when: >
    not current_service_file.stat.exists or
    (current_service_file.stat.exists and current_service_file.stat.md5 != new_service_file.stat.md5)
  register: service_file_updated
- name: invoke systemctl daemon-reload if service file was changed
  command: systemctl daemon-reload
  when:
  - service_file_updated is defined and service_file_updated.rc == 0
- name: restart guix-daemon if service file was changed
  service:
    name: guix-daemon
    state: restarted
  when:
  - service_file_updated is defined and service_file_updated.rc == 0
- name: start guix-daemon if it isn't already started
  service:
    name: guix-daemon
    state: started
- name: enable guix-daemon
  service:
    name: guix-daemon
    enabled: yes

# tell guix to import the hydra public key, only if it isn't already imported
- name: get hydra pubkey
  command: grep '(n' {{ HYDRA_PUBKEY_FILE }}
  register: hydra_pubkey_line
  failed_when: hydra_pubkey_line.rc == 2  # grep exit code 2 means "error"
  changed_when: false
  always_run: yes
- name: check that the guix acl file exists
  stat:
    path: "{{ GUIX_ACL }}"
  register: guix_acl_file
- name: look for hydra pubkey in {{ GUIX_ACL }}
  command: grep -q {{ hydra_pubkey_line.stdout.split('#')[1] }} {{ GUIX_ACL }}
  register: hydra_pubkey_found
  failed_when: hydra_pubkey_found.rc == 2  # grep exit code 2 means "error"
  changed_when: false
  when: guix_acl_file.stat.exists
  always_run: yes
- name: enable the gnu substitutes server
  shell: guix archive --authorize < {{ HYDRA_PUBKEY_FILE }}
  # grep exit code 1 means "no matches"
  when: >
    not guix_acl_file.stat.exists or
    hydra_pubkey_found.rc == 1
